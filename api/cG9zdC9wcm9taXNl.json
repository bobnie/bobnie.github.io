{"title":"Promise 对象","date":"2018-04-22T03:22:45.000Z","slug":"promise","tags":["es6"],"categories":["JS"],"updated":"2018-04-22T15:51:52.000Z","content":"<p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>\n<h2 id=\"\"><a id=\"more\"></a><a href=\"post/promise#\"></a></h2><p><strong>1.Promise 的含义</strong></p>\n<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>\n<p>Promise对象有以下两个特点。</p>\n<p>（1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p>\n<p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p>\n<p>注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。</p>\n<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>\n<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>\n<p>如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。</p>\n<p><strong>2.基本用法</strong></p>\n<p>Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p>\n<pre><code>promise.then(function(value) {\n  // success\n}, function(error) {\n  // failure\n});\n</code></pre><p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>\n<p>我们来看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败：</p>\n<pre><code>function test(resolve, reject) {\n    var timeOut = Math.random() * 2;\n    log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;);\n    setTimeout(function () {\n        if (timeOut &lt; 1) {\n            log(&apos;call resolve()...&apos;);\n            resolve(&apos;200 OK&apos;);\n        }\n        else {\n            log(&apos;call reject()...&apos;);\n            reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;);\n        }\n    }, timeOut * 1000);\n}                                                                            \n</code></pre><p>这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用resolve(‘200 OK’)，如果执行失败，我们将调<br>用reject(‘timeout in ‘ + timeOut + ‘ seconds.’)。<br>可以看出，test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果。</p>\n<p>下面是异步加载图片的例子。</p>\n<pre><code>function loadImageAsync(url) {\n  return new Promise(function(resolve, reject) {\n    const image = new Image();\n    image.onload = function() {\n      resolve(image);\n    };\n    image.onerror = function() {\n      reject(new Error(&apos;Could not load image at &apos; + url));\n    };\n    image.src = url;\n  });\n}\n</code></pre><p>上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。</p>\n<p>下面是一个用Promise对象实现的 Ajax 操作的例子。</p>\n<pre><code>const getJSON = function(url) {\n  const promise = new Promise(function(resolve, reject){\n    const handler = function() {\n      if (this.readyState !== 4) {\n        return;\n      }\n      if (this.status === 200) {\n        resolve(this.response);\n      } else {\n        reject(new Error(this.statusText));\n      }\n    };\n    const client = new XMLHttpRequest();\n    client.open(&quot;GET&quot;, url);\n    client.onreadystatechange = handler;\n    client.responseType = &quot;json&quot;;\n    client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;);\n    client.send();\n  });\n  return promise;\n};\ngetJSON(&quot;/posts.json&quot;).then(function(json) {\n  console.log(&apos;Contents: &apos; + json);\n}, function(error) {\n  console.error(&apos;出错了&apos;, error);\n});\n</code></pre><p>上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>\n<p><strong>(注意)</strong>finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>\n<pre><code>promise\n.then(result =&gt; {···})\n.catch(error =&gt; {···})\n.finally(() =&gt; {···});\n</code></pre><p>上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。</p>\n<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。</p>\n<pre><code>server.listen(port)\n  .then(function () {\n    // ...\n  })\n  .finally(server.stop);\n</code></pre><p>finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p>\n<p>finally本质上是then方法的特例。</p>\n<pre><code>promise\n.finally(() =&gt; {\n  // 语句\n});\n\n// 等同于\npromise\n.then(\n  result =&gt; {\n    // 语句\n    return result;\n  },\n  error =&gt; {\n    // 语句\n    throw error;\n  }\n);\n</code></pre><p>上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。</p>\n<p>它的实现也很简单。</p>\n<pre><code>Promise.prototype.finally = function (callback) {\n  let P = this.constructor;\n  return this.then(\n    value  =&gt; P.resolve(callback()).then(() =&gt; value),\n    reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason })\n  );\n};\n</code></pre><p>上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。</p>\n<p>从上面的实现还可以看到，finally方法总是会返回原来的值。</p>\n<pre><code>// resolve 的值是 undefined\nPromise.resolve(2).then(() =&gt; {}, () =&gt; {})\n\n// resolve 的值是 2\nPromise.resolve(2).finally(() =&gt; {})\n\n// reject 的值是 undefined\nPromise.reject(3).then(() =&gt; {}, () =&gt; {})\n\n// reject 的值是 3\nPromise.reject(3).finally(() =&gt; {})\n</code></pre><p>除了串行执行若干异步任务外，Promise还可以并行执行异步任务。</p>\n<p>试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下：</p>\n<pre><code>var p1 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 500, &apos;P1&apos;);\n});\nvar p2 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 600, &apos;P2&apos;);\n});\n// 同时执行p1和p2，并在它们都完成后执行then:\nPromise.all([p1, p2]).then(function (results) {\n    console.log(results); // 获得一个Array: [&apos;P1&apos;, &apos;P2&apos;]\n});\n</code></pre><p>有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现：</p>\n<pre><code>var p1 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 500, &apos;P1&apos;);\n});\nvar p2 = new Promise(function (resolve, reject) {\n    setTimeout(resolve, 600, &apos;P2&apos;);\n});\nPromise.race([p1, p2]).then(function (result) {\n    console.log(result); // &apos;P1&apos;\n});\n</code></pre><p>由于p1执行较快，Promise的then()将获得结果’P1’。p2仍在继续执行，但执行结果将被丢弃。</p>\n<p>如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。</p>\n<hr>\n<h1 id=\"至此，基本操作介绍完毕-如果有什么问题，欢迎评论问我，看到一定回复\"><strong>至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复</strong><a href=\"post/promise#至此，基本操作介绍完毕-如果有什么问题，欢迎评论问我，看到一定回复\"></a></h1><hr>\n","next":{"title":"简说css浮动","slug":"简说css浮动"},"link":"http://yoursite.com/post/promise/","toc":[{"title":"<strong>至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复</strong>","id":"至此，基本操作介绍完毕-如果有什么问题，欢迎评论问我，看到一定回复","index":"1"}]}