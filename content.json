{"pages":[],"posts":[{"title":"js事件冒泡","text":"浅谈js事件冒泡，前端笔记 下面我们来看看一段代码 &lt;!DOCTYPE html&gt; &lt;html lang=“en”&gt; &lt;head&gt; &lt;meta charset=“UTF-8”&gt; &lt;title&gt;test&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;Click me!&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 如果你点击了其中的div元素，那么这个click事件会按照如下顺序传播: 1.&lt;div&gt; 2.&lt;body&gt; 3.&lt;html&gt; 4.&lt;document&gt; 也就是说，click事件首先在 元素上发生，而这个元素就是我们单击的元素。然后，click事件沿着DOM树向上传播，在每一级节点上都会发生，直至传播到 document 对象。 注意：所有现代浏览器都支持事件冒泡，但在具体实现上还是有些差别。IE5.5及更早版本中的事件冒泡会跳过 元素（从 直接跳到 document）。IE9、Firefox、Chrome和Safari则将事件一直冒泡到windows对象。 好了，那么在理论的基础上，我写了如下实例代码: &lt;!DOCTYPE html&gt; &lt;html lang=“en”&gt; &lt;head&gt; &lt;meta charset=“UTF-8”&gt; &lt;title&gt;test&lt;/title&gt; &lt;style&gt; #father { width: 300px; height: 300px; background: orange; overflow: hidden; } #son { width: 100px; height: 100px; margin: 50px; background: red; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=‘father’&gt; &lt;div id=“son”&gt;&lt;/div&gt; &lt;/div&gt; &lt;script type=“text/javascript”&gt; var father = document.getElementById(‘father’); var son = document.getElementById(‘son’); function stopPropagation(event) { e = window.event || event; if(e.stopPropagation) { e.stopPropagation(); } else { e.cancelBubble = true; } } father.onclick = function(e) { alert(‘father’); stopPropagation(e); } son.onclick = function(e) { alert(‘son’); stopPropagation(e); } &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 其中的这一段是为了兼容各浏览器而写的，希望各位看官注意: function stopPropagation(event) { e = window.event || event; if(e.stopPropagation) { e.stopPropagation(); } else { e.cancelBubble = true; } } 在这里，我们在点击 son 元素的时候，阻止了事件向上冒泡，这样，当我们点击 son 元素的时候就不会触发 father 元素的点击事件了。 注意，不是所有的事件都可以冒泡，其中blur、focus、load、unload不能冒泡。 好了，JS事件冒泡就写到这里了，希望各位看官能有所收获，照例，如有错误，欢迎指出：) 。 === 至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复","link":"/2017/12/06/js事件冒泡/"},{"title":"VIP视频解析使用教程","text":"最近很火的东东：VIP视频解析，可以跳过vip会员免费看大部分视频，可能有的童鞋也知道也用过了，但是还是有很多童鞋不懂，再这里做个简单的使用教程。 项目地址： 此网址为转载，在这里分享给大家(http://v.laod.cn/) 找一个你需要看的视频地址，复制地址到项目的【视频地址】里，然后点击【播放】即可。 如果无法播放，请换个【接口】 注意事项： 腾讯视频先选2号接口 再点击线路6就可以啦 关于不能看部分视频说明： 如开头说述，只能看大部分视频，像爱奇艺的一些视频使用了DRM码流 所以是不能观看的。 关于DRM码流： 百度旗下的爱奇艺视频与 Intertrust 技术公司宣布：国内领先的互联网视频提供商爱奇艺视频将使用 Intertrust 的 ExpressPlay Marlin DRM 平台作为爱奇艺在线视频服务的内容保护方案。 ExpressPlay 是 Marlin DRM 平台云服务解决方案。 Intertrust 拥有世界一流的版权保护方案，提供 DRM 云服务器及可以用于 iPhone 、 iPad 、 Android 设备以及智能电视和机顶盒的跨平台客户端解决方案。ExpressPlay是世界上唯一的一站式 DRM 平台。该方案提供云端 DRM 服务器和跨平台客户端技术。ExpressPlay 的客户端软件应用了防破解保护，可以很容易的整合到播放器应用程序。 免责声明： 本项目的所有接口均来自互联网以及网页提供，仅供学习交流使用，我们尊重任何视频版权, 请遵循相关法律法规，本站一切资源不代表本站立场，如果无意侵犯了您的合法权益，请联系我们，我们将及时处理。 至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复","link":"/2017/12/04/VIP视频解析使用教程/"},{"title":"搭建你的Hexo博客","text":"早就想在github上搭建属于自己的博客了，一直没有腾出时间，Jekyll也觉得一般，前一阵一个朋友推荐hexo，看了看文档，很不错，也决定用hexo搭建一个自己的博客，下面是我摘自网络的教程，想搭建自己博客的朋友可以自己动手试一试。 hexo出自台湾大学生tommy351之手，是一个基于Node.js的静态博客程序，其编译上百篇文字只需要几秒。hexo生成的静态网页可以直接放到GitHub Pages，BAE，SAE等平台上。先看看tommy是如何吐槽Octopress的 →＿→ Hexo颯爽登場。 如果你对默认配置满意，只需几个命令便可秒搭一个hexo。 如果你跟我一样喜欢折腾下，30分钟也足够个性化。 如果你过于喜欢折腾，可以折腾个把星期，尽情的玩。 搭建过程你或许觉得有那么点小繁琐，但一旦搭建完成，写文章是极简单，极舒服的。只需要几个简单命令，你就可以完成一切。 hexo n #写文章 hexo g #生成 hexo d #部署 # 可与hexo g合并为 hexo d -g 下面逐步介绍，进入正题。 环境准备安装Node到Node.js官网下载相应平台的最新版本，一路安装即可。我用的是node-v0.10.22-x86.msi安装GitGit的客户端很多，我用的是msysgit，喜欢用绿色版本Portable application for official Git for Windows 1.8.4，下载下来设置一下环境变量即可，Git_HOME，%Git_HOME%\\bin之类的，不多说。安装Sublime（可选）Sublime Text 2在这里仅仅作为一个文本编辑器使用，支持各种编程语言和文件格式，当然也支持Markdown语法，实在是个不可多得的练码奇才。喜欢追鲜的也可以尝试处于beta版本的Sublime Text 3。我用绿色版本Portable Sublime Text 2.0.2.zip。 本屌是穷码畜，对于高大上的Mac码帅用户请移步：hexo installation GitHub GitHub账号和GitHub Pages 一般都应该有吧，已有的请自动无视这一部分。 首先注册一个『GitHub』帐号，已有的默认默认请忽略 建立与你用户名对应的仓库，仓库名必须为『your_user_name.github.com』 添加SSH公钥到『Account settings -&gt; SSH Keys -&gt; Add SSH Key』 前两步忽略，只说第三步，添加SSH-Key。 首先设置你的用户名密码(邮箱和用户名改你自己的，下同)： git config --global user.email &quot;bu.ru@qq.com&quot; git config --global user.name &quot;bruce-sha&quot; 生成密钥： ssh-keygen -t rsa -C &quot;bu.ru@qq.com&quot; 输入文件路径： H:\\hexo\\blog&gt;ssh-keygen -t rsa -C &quot;bu.ru@qq.com&quot; Generating public/private rsa key pair. Enter file in which to save the key (//.ssh/id_rsa): H:\\git\\myssh\\ssh Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in H:\\git\\myssh\\ssh. Your public key has been saved in H:\\git\\myssh\\ssh.pub. The key fingerprint is: b0:0c:2e:67:33:ab:c1:50:10:40:0a:ba:c1:80:59:22 bu.ru@qq.com 有个bug，文件路径中的盘符H必须大写，否则会报错。 上述命令若执行成功，会在H:\\git\\myssh目录下生成两个文件id_rsa和id_rsa.pub，最后两步： 1.用文本编辑器打开ssh.pub文件，拷贝其中的内容，将其添加到Add SSH Key2.将id_rsa和id_rsa.pub拷贝至你Git安装目录下的.ssh目录，如H:\\PortableGit-1.8.4.ssh 最后可以验证一下： ssh -T git@github.com 若有问题，请重新设置。常见错误请参考：GitHub Help - Generating SSH KeysGitHub Help - Error Permission denied (publickey) 安装Node和Git都安装好后，可执行如下命令安装hexo： npm install -g hexo 初始化然后，执行init命令初始化hexo到你指定的目录： hexo init &lt;folder&gt; 也可以cd到目标目录，执行hexo init。 好啦，至此，全部安装工作已经完成！ 生成静态页面cd 到你的init目录，执行如下命令，生成静态页面至hexo\\public\\目录。 hexo generate 命令必须在init目录下执行，否则不成功，但是也不报错。 当你修改文章Tag或内容，不能正确重新生成内容，可以删除hexo\\db.json后重试，还不行就到public目录删除对应的文件，重新生成。 本地启动执行如下命令，启动本地服务，进行文章预览调试。 hexo server 浏览器输入 http://localhost:4000 就可以看到效果。 请使用高级浏览器，否则可能…你懂的！ 写文章执行new命令，生成指定名称的文章至hexo\\source_posts\\postName.md。 hexo new [layout] &quot;postName&quot; #新建文章 其中layout是可选参数，默认值为post。有哪些layout呢，请到scaffolds目录下查看，这些文件名称就是layout名称。当然你可以添加自己的layout，方法就是添加一个文件即可，同时你也可以编辑现有的layout，比如post的layout默认是hexo\\scaffolds\\post.md title: { { title } } date: { { date } } tags: --- 请注意，大括号与大括号之间我多加了个空格，否则会被转义，不能正常显示。 我想添加categories，以免每次手工输入，只需要修改这个文件添加一行，如下: title: { { title } } date: { { date } } categories: tags: --- postName是md文件的名字，同时也出现在你文章的URL中，postName如果包含空格，必须用”将其包围，postName可以为中文。 注意，所有文件：后面都必须有个空格，不然会报错。 看一下刚才生成的文件hexo\\source_posts\\postName.md，内容如下： title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中 date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改 categories: #文章分类目录，可以为空，注意:后面有个空格 tags: #文章标签，可空，多标签请用格式[tag1,tag2,tag3]，注意:后面有个空格 --- 这里开始使用markdown格式输入你的正文。 接下来，你就可以用喜爱的编辑器尽情书写你的文章。关于markdown语法，可以参考我的文章Markdown简明语法。fancybox可能有人对这个Reading页面中图片的fancybox效果感兴趣，这个是怎么做的呢。很简单，只需要在你的文章*.md文件的头上添加photos项即可，然后一行行添加你要展示的照片： layout: photo title: 我的阅历 date: 2085-01-16 07:33:44 tags: [hexo] photos: - http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg - http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg 经过测试，文件头上的layout: photo可以省略。 不想每次都手动添加怎么办？同样的，打开您的hexo\\scaffolds\\photo.md layout: { { layout } } title: { { title } } date: { { date } } tags: photos: - --- 然后每次可以执行带layout的new命令生成照片文章： hexo new photo &quot;photoPostName&quot; #新建照片文章 descriptionmarkdown文件头中也可以添加description，以覆盖全局配置文件中的description内容，请参考下文_config.yml的介绍。 title: hexo你的博客 date: 2013-11-22 17:11:54 categories: default tags: [hexo] description: 你对本页的描述 --- hexo默认会处理全部markdown和html文件，如果不想让hexo处理你的文件，可以在文件头中加入layout: false。 文章摘要:在需要显示摘要的地方添加如下代码即可： 以上是摘要 &lt;!--more--&gt; 以下是余下全文 more以上内容即是文章摘要，在主页显示，more以下内容点击『&gt; Read More』链接打开全文才显示。 hexo中所有文件的编码格式均是UTF-8。 主题安装萝卜白菜各有所爱，玩博客换主题是必不可少的，hexo的主题列表Hexo Themes。我比较喜欢pacman，modernist、ishgo，raytaylorism。Pacman最为优秀，简洁大方小清新，同时移动版本支持的也很好，但作者并没有把很多参数分离出来给出可配置项，我最终选择了modernist。 安装主题的方法就是一句git命令： git clone https://github.com/heroicyang/hexo-theme-modernist.git themes/modernist 目录是否是modernist无所谓，只要与_config.yml文件一致即可。 安装完成后，打开hexo_config.yml，修改主题为modernist theme: modernist 打开hexo\\themes\\modernist目录，编辑主题配置文件_config.yml： menu: #配置页头显示哪些菜单 # Home: / Archives: /archives Reading: /reading About: /about # Guestbook: /about excerpt_link: Read More #摘要链接文字 archive_yearly: false #按年存档 widgets: #配置页脚显示哪些小挂件 - category # - tag - tagcloud - recent_posts # - blogroll blogrolls: #友情链接 - bruce sha&apos;s duapp wordpress: http://ibruce.duapp.com - bruce sha&apos;s javaeye: http://buru.iteye.com - bruce sha&apos;s oschina blog: http://my.oschina.net/buru - bruce sha&apos;s baidu space: http://hi.baidu.com/iburu fancybox: true #是否开启fancybox效果 duoshuo_shortname: buru #多说账号 google_analytics: rss: 更新主题 cd themes/modernist git pull 评论框静态博客要使用第三方评论系统，hexo默认集成的是Disqus，因为你懂的，所以国内的话还是建议用多说。直接用你的微博/豆瓣/人人/百度/开心网帐号登录多说，做一下基本设置。如果使用modernist主题，在modernist_config.yml中配置duoshuo_shortname为多说的基本设置-&gt;域名中的shortname即可。你也可以在多说后台自定义一下多说评论框的格式，比如评论框的位置，对于css设置，可以参考这里，我是在HeroicYang的基础上修改的。 如果你是有的其他第三方评论系统，将通用代码粘贴到hexo\\themes\\modernist\\layout_partial\\comment.ejs里面，如下： &lt;% if (config.disqus_shortname &amp;&amp; page.comments){ %&gt; &lt;section id=&quot;comment&quot;&gt; #你的通用代码 &lt;% } %&gt; 自定义页面执行new page命令 hexo new page &quot;about&quot; 在hexo\\source\\下会生成about目录，里面有个index.md，直接编辑就可以了，然后在主题的_config.yml中将其配置显示出来。上述步骤，也可以手工生成，在hexo\\source\\下手工新建about和index.md也是完全等价的。 因为markdown对table的支持不好，我是在about中直接建立index.html，里面书写页面内容，hexo会帮你加上头和尾。 404页面GitHub Pages 自定义404页面非常容易，直接在根目录下创建自己的404.html就可以。但是自定义404页面仅对绑定顶级域名的项目才起作用，GitHub默认分配的二级域名是不起作用的，使用hexo server在本机调试也是不起作用的。其实，404页面可以做更多有意义的事，来做个404公益项目吧。做点有意义的事情，也对得起这个域名。目前有如下几个公益404接入地址，我选择了腾讯的。404页面，每个人可以做的更多。 腾讯公益404 404公益_益云(公益互联网)社会创新中心 失蹤兒童少年資料管理中心404 图床考虑到博客的速度，同时也为了便于博客的迁移，图床是必须的。我墙裂推荐七牛，访问速度极快，支持日志、防盗链和水印。 免费用户有每月10GB流量+总空间10GB+PUT/DELETE 10万次请求+GET 100万次请求，这对个人博客来说足够，也可通过邀请好友获得奖励。有一点要说明的是，七牛没有目录的概念，但是文件名可以包含/，比如2013/11/27/reading/photos-0.jpg，参考这里关于key-value存储系统。 七牛除了作为图床还可以作为其他静态文件存储空间，比如我的个人站点首页有个字库文件和JS文件下载较慢，有时间会把它弄到七牛上去，以提高首页打开速度。请看这篇Linux中国采用七牛云存储支撑图片访问。 如果非要说不足的话，就是文件管理界面不是很友好，不支持CNAME到分配的永久链接，也不能绑定未备案的自有域名，必须备案才可以。 如果你对七牛web版的文件管理界面不满意，可以用官方的七牛云存储工具。 您还可以使用如下图床服务 FarBox，Dropbox，又拍云。 申请域名（可选）GitHubPages默认为每个用户分配了一个二级域名『your_user_name.github.com』或『your_user_name.github.io』。如果你对上述域名不满意，可以到狗爹，或者万网上申请一个自己的域名，然后绑定到GitHub Pages。绑定方法很简单，在repo根目录下建立一个CNAME文件，里面写上域名即可。 GoDaddy买域名首选狗爹，国内的服务商大家都懂的。目前.info域名只要￥18.99，但据说续费比较贵，我是先玩下，一年后再换，至于搜索引擎重新索引之类的，无所谓。.me和.com域名稍微贵点，大约￥60-100，网上有很多优惠码可用，可惜有的优惠码有限制。比如有个.com域名优惠码只要$1.99，但只能用国外信用卡购买。更多优惠码可以自行谷歌或到独特优惠码找。不着急的同学可以将中意的域名加入购物车先不付款，过几天，狗爹就会发优惠信息给你。狗爹不定期也会有活动，可以多关注。付款后，需要稍微等一会你才会拿到域名，特别是支付宝付款的，要等大约半小时左右。此外域名要一年年的买，这样比较划算。 建议大家申请.com或.me域名。据说.info因垃圾网站太多，被搜索引擎惩罚，而且续费较贵。 DNSPodGoDaddy的NameServers有时会被墙，因此墙裂推荐国内的DNSPod解析域名，免费服务真心不错。支持微信/邮件提醒，监控与报警，访问统计，健康诊断，搜索引擎推送，速度哇哇的，对于我来说足够。两步设置就可以搞定，怎么操作参考Godaddy注册商域名修改DNS地址。 命令常用命令： hexo new &quot;postName&quot; #新建文章 hexo new page &quot;pageName&quot; #新建页面 hexo generate #生成静态页面至public目录 hexo server #开启预览访问端口（默认端口4000，&apos;ctrl + c&apos;关闭server） hexo deploy #将.deploy目录部署到GitHub 常用复合命令： hexo deploy -g hexo server -g 简写： hexo n == hexo new hexo g == hexo generate hexo s == hexo server hexo d == hexo deploy 至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复","link":"/2017/11/25/newHexo/"},{"title":"Promise 对象","text":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6 将其写进了语言标准，统一了用法，原生提供了Promise对象。 1.Promise 的含义 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 注意，为了行文方便，本章后面的resolved统一只指fulfilled状态，不包含rejected状态。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用 Stream 模式是比部署Promise更好的选择。 2.基本用法 Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 promise.then(function(value) { // success }, function(error) { // failure }); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 我们来看一个最简单的Promise例子：生成一个0-2之间的随机数，如果小于1，则等待一段时间后返回成功，否则返回失败： function test(resolve, reject) { var timeOut = Math.random() * 2; log(&apos;set timeout to: &apos; + timeOut + &apos; seconds.&apos;); setTimeout(function () { if (timeOut &lt; 1) { log(&apos;call resolve()...&apos;); resolve(&apos;200 OK&apos;); } else { log(&apos;call reject()...&apos;); reject(&apos;timeout in &apos; + timeOut + &apos; seconds.&apos;); } }, timeOut * 1000); } 这个test()函数有两个参数，这两个参数都是函数，如果执行成功，我们将调用resolve(‘200 OK’)，如果执行失败，我们将调用reject(‘timeout in ‘ + timeOut + ‘ seconds.’)。可以看出，test()函数只关心自身的逻辑，并不关心具体的resolve和reject将如何处理结果。 下面是异步加载图片的例子。 function loadImageAsync(url) { return new Promise(function(resolve, reject) { const image = new Image(); image.onload = function() { resolve(image); }; image.onerror = function() { reject(new Error(&apos;Could not load image at &apos; + url)); }; image.src = url; }); } 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的 Ajax 操作的例子。 const getJSON = function(url) { const promise = new Promise(function(resolve, reject){ const handler = function() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; const client = new XMLHttpRequest(); client.open(&quot;GET&quot;, url); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); client.send(); }); return promise; }; getJSON(&quot;/posts.json&quot;).then(function(json) { console.log(&apos;Contents: &apos; + json); }, function(error) { console.error(&apos;出错了&apos;, error); }); 上面代码中，getJSON是对 XMLHttpRequest 对象的封装，用于发出一个针对 JSON 数据的 HTTP 请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 (注意)finally方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。 promise .then(result =&gt; {···}) .catch(error =&gt; {···}) .finally(() =&gt; {···}); 上面代码中，不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。 下面是一个例子，服务器使用 Promise 处理请求，然后使用finally方法关掉服务器。 server.listen(port) .then(function () { // ... }) .finally(server.stop); finally方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是fulfilled还是rejected。这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。 finally本质上是then方法的特例。 promise .finally(() =&gt; { // 语句 }); // 等同于 promise .then( result =&gt; { // 语句 return result; }, error =&gt; { // 语句 throw error; } ); 上面代码中，如果不使用finally方法，同样的语句需要为成功和失败两种情况各写一次。有了finally方法，则只需要写一次。 它的实现也很简单。 Promise.prototype.finally = function (callback) { let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason }) ); }; 上面代码中，不管前面的 Promise 是fulfilled还是rejected，都会执行回调函数callback。 从上面的实现还可以看到，finally方法总是会返回原来的值。 // resolve 的值是 undefined Promise.resolve(2).then(() =&gt; {}, () =&gt; {}) // resolve 的值是 2 Promise.resolve(2).finally(() =&gt; {}) // reject 的值是 undefined Promise.reject(3).then(() =&gt; {}, () =&gt; {}) // reject 的值是 3 Promise.reject(3).finally(() =&gt; {}) 除了串行执行若干异步任务外，Promise还可以并行执行异步任务。 试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下： var p1 = new Promise(function (resolve, reject) { setTimeout(resolve, 500, &apos;P1&apos;); }); var p2 = new Promise(function (resolve, reject) { setTimeout(resolve, 600, &apos;P2&apos;); }); // 同时执行p1和p2，并在它们都完成后执行then: Promise.all([p1, p2]).then(function (results) { console.log(results); // 获得一个Array: [&apos;P1&apos;, &apos;P2&apos;] }); 有些时候，多个异步任务是为了容错。比如，同时向两个URL读取用户的个人信息，只需要获得先返回的结果即可。这种情况下，用Promise.race()实现： var p1 = new Promise(function (resolve, reject) { setTimeout(resolve, 500, &apos;P1&apos;); }); var p2 = new Promise(function (resolve, reject) { setTimeout(resolve, 600, &apos;P2&apos;); }); Promise.race([p1, p2]).then(function (result) { console.log(result); // &apos;P1&apos; }); 由于p1执行较快，Promise的then()将获得结果’P1’。p2仍在继续执行，但执行结果将被丢弃。 如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。 至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复","link":"/2018/04/22/promise/"},{"title":"介绍一款编译神器的插件(atom)","text":"Atom是由GitHub開發的自由及开放源代码的文字與程式碼編輯器，支援OS X、Windows和Linux作業系統，支援Node.js所寫的外掛程式，並內建由Github提供的Git版本控制系統。多數的延伸套件皆為開放原始碼授權，並由社群建置與維護。 最近被开发者微博圈刷屏的Atom编辑器插件，插件效果图如下： 如果来点音乐、再配上机械键盘的话，写代码是不是爽到爆呢？ （脑补播放动感的音乐再加上高大上的青轴键盘…最好准备好晕车药 :）） Windows 7安装 1.&lt;span class=&quot;pln&quot;&gt;cd &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;packages 2.git clone https&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;://&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;github&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;JoelBesada&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;activate&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;power&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;git 3.cd activate&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;power&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;mode 4.apm install&lt;/span&gt; Mac安装 atom编辑器安装： &lt;span class=&quot;pln&quot;&gt;sudo brew install &lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Caskroom&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;cask&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;atom &lt;/span&gt;&lt;span class=&quot;com&quot;&gt;#OS X 10.11.不支持通过命令行安装&amp;amp;可通过下载DMG文件安装&lt;/span&gt; atom-install shell command 1.&lt;span class=&quot;pln&quot;&gt;cd &lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;Users&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;$yourname&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;atom&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;packages 2.git clone https&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;://&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;github&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;com&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;typ&quot;&gt;JoelBesada&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;/&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;activate&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;power&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;mode&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;git 3.cd activate&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;power&lt;/span&gt;&lt;span class=&quot;pun&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;pln&quot;&gt;mode 4.apm install 5.apm ls &lt;/span&gt;&lt;span class=&quot;com&quot;&gt;#检测是否安装成功&lt;/span&gt; Packages-Activate Power Mode: Toggle 网页效果demo：http://kushagragour.in/code-blast-codemirror/demo/index.html atom.io:https://atom.io/packages/activate-power-mode 至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复","link":"/2017/12/04/介绍一款编译神器的插件-atom/"},{"title":"Linux之文件权限","text":"Linux之文件权限 三种权限： 读 - 允许分组读文件（用 r 表示） 写 - 允许分组写文件（用 w 表示） 执行 - 允许分组执行（运行）文件（用 x 表示） 四个分组： user - 文件实际的拥有者 group - 用户所在的用户组 others - 用户租外的其他用户 all - 所有用户 打开终端并允许 ls -l （或 ll ）结果如下 1.[root@localhost test]# pwd 2./usr/local/test 3.[root@localhost test]# ls -l 4.total 4 5.drwxr-xr-x 2 root root 4096 Jun 14 21:40 demo 6.-rw-r--r-- 1 root root 0 Jun 14 21:47 helloworld.java 注意最左边的像：drwxr-xr-x 应该这样看 d rwx r-x r-x 列表3部分： rwx r-x r-x 组和权限的顺序都很重要，顺序总是： 所属者 所属组 其他人 - 分组 读 写 执行 - 权限 权限还可以用数字表示： 读 - 4 写 - 2 执行 - 1 rwxr-xr-x 可替换 4214-14-1 也可以分组 755 如果你想给文件755权限，可以使用chmod 775 filename 让自己有权限执行 chmod u+x test.sh 让用户及所属组同时拥有执行权限 chmod ug+x test.sh 想去取其他用户的执行权限 chmod o-x test.sh 完全删除文件的可执行权限 chmod a-x test.sh 或者 chmod ugo-x test.sh 开头的 d 代表这是一个目录 假设文件夹demo（包括demo文件夹）及里面的一些脚本，你想移除用户组的写权限 chmod -R g-w demo 参数 R 意味着递归的 chmod 命令 至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复","link":"/2017/11/25/Linux之文件权限/"},{"title":"简说css浮动","text":"了解一下css浮动基本规则 说到元素的浮动，首先要明确一个概念就是包含块(containing block)。 所谓浮动元素的包含块，就是其最近的块级祖先元素。我们后面会举例来说明。 这里关于浮动的问题，主要有以下几点： 1、浮动元素的外边界不能超过其包含块的内边界。 2、浮动元素的外边界是另一浮动元素的外边界。 3、浮动元素的顶端不能比之前出现的浮动元素的顶端更高。 4、浮动元素顶端不超过当前行。 5、clear属性。 1、浮动元素的外边界不能超过其包含块的内边界。 我们看以下代码： &lt;div class=“col-md-6” id=“outerBlock”&gt; &lt;img src=“images/test1.jpg” style=“float:right” alt=“plane” id=“image1”/&gt; &lt;p id=“p1”&gt;Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. One day in the Year of the Fox Came a time remembered well, WheOne day, in the Year of the Fox Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. &lt;/p&gt; &lt;/div&gt; 这段代码看第来比较长，实际上只有3个元素，最外层的div#outerBlock以及其中包含的img#image1和p#p1。 注意代码第2行，我们让img#image1元素向右浮动，此时，该img元素的包含块就为div#outerBlock，也就是最外层的div块。 这段代码会呈现什么效果呢？为了更加清晰地说明问题，我们这里分别给div#outerBlock以及p#p1加上边框以及内边距： div#outerBlock { border: 1px dotted; padding: 3em; } p#p1 { border: 1px solid; padding: 3em; } 效果如下： 这里我们可以清楚地看到div#outerBlock、img#image1以及p#p1三者的位置关系。 div#outerBlock是img元素的包含块，img元素的外边界不得超过其包含块的内边界。由于div#outerBlock元素增加了内边距padding=3em，故img元素的最右侧以及最上侧为虚线内3em。 如果我们给img元素加上2em的外边距，可以预料到img元素右侧及上侧将会为虚线内5em。如下： img#image1 { margin: 2em; } 虽然看起来img元素很像包含在实线围起来的p元素中，事实上它的位置时依据它的包含块——虚线确定的，只是给img元素增加了2em的外边距，根据浮动元素外边界不超过其包含块内边界的原则，图像的边界将距离虚线5em。 接下来，我们做一些改变，将img元素放到p#p1中去，如下： &lt;div class=“col-md-6” id=“outerBlock”&gt; &lt;p id=“p1”&gt;Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. &lt;img src=“images/test1.jpg” style=“float:right” alt=“plane” id=“image1”/&gt; There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. One day in the Year of the Fox Came a time remembered well, WheOne day, in the Year of the Fox Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. &lt;/p&gt; &lt;/div&gt; 注意看第9行，将img元素插入到了p元素中间。此时，img元素的包含块就变成了p#p1，页面结果如下： 同样是浮动元素外边界不超过其包含块内边界的原则，此时图像的边距离实线距离为2em+3em=5em。此时的位置是根据实线确定的。 2、浮动元素的外边界是另一浮动元素的外边界。 关于这个问题，实际上是为了避免浮动元素彼此之间的覆盖。也就是说，如果一个向右浮动的元素，碰到了另一个浮动元素，那么它的外边界将是碰到的那个浮动元素的外边界。 看下面的例子，这里我们包含2个img元素在p块中： &lt;div class=“col-md-6” id=“outerBlock”&gt; &lt;p id=“p1”&gt;Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. &lt;img src=“images/test1.jpg” style=“float:right” alt=“plane” id=“image1”/&gt; There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, &lt;img src=“images/test1.jpg” style=“float:right” alt=“plane” id=“image2”/&gt; “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. One day in the Year of the Fox Came a time remembered well, WheOne day, in the Year of the Fox Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. &lt;/p&gt; &lt;/div&gt; 注意看代码的9行以及15行，这里我们插入了2个img元素img#image1和img#image2。为了更清楚地展示以上准则，这里给img元素加上内边距以及边框： img#image1 { padding: 2em; border: 1px solid; } img#image2 { padding: 2em; border: 1px solid; } 得到的效果如下： 说明一下，这里插入内边距是为了使边框更加清晰地展示边界。实际上，正如上面说的，浮动元素的外边界是另一浮动元素的外边界。 这里还有一个细节问题，如果一个包含块中有2个浮动元素，并且这2个浮动元素的外边距宽度之和大于包含块的宽度，那么这2个浮动元素便只能上下排列，如下： 3、浮动元素的顶端不能比之前出现的浮动元素的顶端更高。 这句话看起来很抽象，具体来说，假如现在有3个浮动块。第2个块在第1个块的下面，那么第3个块的顶端就是第2个块的顶端，而不会一直浮动到它们的包含块的内边界。 请看下面的代码，我们插入3个浮动块： &lt;div class=“col-md-6” id=“outerBlock”&gt; &lt;img src=“images/test3.jpg” style=“float:left” alt=“plane” id=“image1”/&gt; &lt;img src=“images/test4.jpg” style=“float:left” alt=“plane” id=“image2”/&gt; &lt;img src=“images/test1.jpg” style=“float:right” alt=“plane” id=“image3”/&gt; &lt;p id=“p1”&gt;Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. One day in the Year of the Fox Came a time remembered well, WheOne day, in the Year of the Fox Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. &lt;/p&gt; &lt;/div&gt; 注意代码的2、3、4行，我们插入了3个浮动img块。 其中，img#image1向左浮动，img#image2向左浮动，img#image3向右浮动。前2个浮动块由于宽度之和超出了它们的包含块，它们将上下排列，第3个浮动img的上边界是第2个浮动img的上边界，而不是第1个！如下图所示： 如上图所示，第三个浮动块img3，也就是右侧的小飞机，它的上边界不会超过在它之前的浮动元素的上边界。也就是说，它不会一直浮动到和img1等高的位置，它的上边界不超过img2的上边界。 4、浮动元素顶端不超过当前行 这条规则同3的功能类似，作用在于约束浮动块的上浮。主要针对浮动元素之前出现另一元素的情况而言。其实上面我们也看到了，只是没有刻意地拿出来说。不妨举两种情况作为例子来说。 第一种，在一个段落里，出现一个浮动元素。 &lt;div class=“col-md-6” id=“outerBlock”&gt; &lt;p id=“p1”&gt;Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. &lt;img src=“images/test1.jpg” style=“float:right” alt=“plane” id=“image1”/&gt; There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. One day in the Year of the Fox Came a time remembered well, WheOne day, in the Year of the Fox Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. &lt;/p&gt; &lt;/div&gt; 注意以上代码的第9行，有一个浮动元素。第4条规则的意思就是说，浮动元素的顶端不会超过其上面To the temple of the king.所在的行。我们具体看以上代码的效果： 第二种情况，如果浮动元素出现在一个段落后面，那么该浮动元素上浮将不能超过该段落的底部。如下： &lt;div class=“col-md-6” id=“outerBlock”&gt; &lt;p id=“p1”&gt;Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. One day in the Year of the Fox Came a time remembered well, WheOne day, in the Year of the Fox Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. &lt;/p&gt; &lt;img src=“images/test1.jpg” style=“float:right” alt=“plane” id=“image1”/&gt; &lt;/div&gt; 我们将浮动块放在代码37行，处于块级兄弟元素p的后面，它的上浮情况如何呢？ 很清楚地看到，浮动元素的顶部在p元素的下方。虽然它的包含块是虚线构成的div元素。 5、clear属性 如果我们不希望我们的某段内容流过浮动元素，我们可以使用clear属性，我们下面对比2种情况来看： &lt;div class=“col-md-3” id=“outerBlock”&gt; &lt;img src=“images/test1.jpg” style=“float:right” alt=“plane” id=“image1”/&gt; &lt;p id=“p1”&gt;Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. One day in the Year of the Fox Came a time remembered well, WheOne day, in the Year of the Fox Came a time remembered well, When the strong young man of the rising sun Heard the tolling of the great black bell. One day in the Year of the Fox, When the bell began to ring, It meant the time had come for one to go To the temple of the king. There in the middle of the circle he stands, Searching, seeking. With just one touch of his trembling hand, The answer will be found. Daylight waits while the old man sings, “Heaven help me!” And then like the rush of a thousand wings, It shines upon the One. And the day has just begun. &lt;/p&gt; &lt;/div&gt; 同样的一段代码，右侧的p元素添加clear:right，这样浮动元素将不会出现在其右侧。该p块将会被向下推，直到浮动元素的下面才会显示。 至此，基本操作介绍完毕,如果有什么问题，欢迎评论问我，看到一定回复","link":"/2017/12/29/简说css浮动/"}],"tags":[{"name":"Js","slug":"Js","link":"/tags/Js/"},{"name":"视频解析","slug":"视频解析","link":"/tags/视频解析/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"es6","slug":"es6","link":"/tags/es6/"},{"name":"插件","slug":"插件","link":"/tags/插件/"},{"name":"权限","slug":"权限","link":"/tags/权限/"},{"name":"css","slug":"css","link":"/tags/css/"}],"categories":[{"name":"Js","slug":"Js","link":"/categories/Js/"},{"name":"hacker","slug":"hacker","link":"/categories/hacker/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"JS","slug":"JS","link":"/categories/JS/"},{"name":"atom","slug":"atom","link":"/categories/atom/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"css","slug":"css","link":"/categories/css/"}]}